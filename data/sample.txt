Apache Hadoopは大規模データの分散処理を支えるJavaソフトウェアフレームワークであり、フリーソフトウェアとして配布されている。[2]Hadoopはアプリケーションが数千ノードおよびペタバイト級のデータを処理することを可能としている。HadoopはGoogleのMapReduceおよびGoogle File System(GFS)論文に触発されたものである。
HadoopはApacheのトップレベルプロジェクトの1つであり、世界規模の開発貢献者コミュニティによって開発され、使用されている。[3]

アーキテクチャ[編集]
Hadoopは、Hadoop がサポートするファイルシステムへのアクセスを提供するHadoop Commonで構成する。ここで、「Rack Awareness」とは、サーバクラスタの地理的位置を考慮した最適化の考えである。つまり、異なる地理的位置にあるサーバ間の網伝送(network traffic)を最小にするということである。[4] 2008年6月現在、下記のファイルシステムをサポートしている。
HDFS: Hadoop独自のファイルシステムである。HDFSは各OSが提供するファイルシステム上で動作し、 数ペタバイトの容量まで拡張するよう設計している。
Amazon S3: このファイルシステムは、Amazon Elastic Compute Cloud (EC2) 環境で構築したクラスタ上で動作する。なお、このAmazon S3 ファイルシステムはRack-awarenessが考慮されておらず、すべてリモートサイトで動作する。
CloudStore（旧 Kosmos Distributed File System）: HDFSのようなRack-Awarenessなファイルシステム。
FTP: すべてのデータをFTPによりアクセス可能なリモートサーバに格納する。
Read-only HTTP and HTTPS.
Hadoop分散ファイルシステム[編集]
Hadoop分散ファイルシステム(HDFS)は大きなファイル（理想的には64MBの倍数[5]）を複数の計算機にまたがり格納することができる。HDFS はデータの複製を複数のホストに格納することで信頼性を確保しているため、各ホストはRAIDを必要としない。デフォルトのレプリケーション数3のとき、データは3つのノードに保存する。この場合、2つのデータを同じラック内のノードに、残りひとつを異なるラックに保存する。
HDFSはデータノード (Data node) のクラスタにより構成する。データノードはそれぞれ、HDFS独自のブロック転送プロトコルによりデータブロックを転送する。データノードはまたHTTPによりデータを提供することができ、WEBブラウザ等のクライアントからのアクセスを処理できる。データノード間はお互いに通信し、データ再配置、データコピー、冗長性維持を行うことができる。
HDFSはネームノード (Name node) と呼ばれる唯一の特殊なノードを必要とする。ネームノードは、HDFSにおけるsingle point of failureである。ネームノードがダウンした場合、ファイルシステムはオフラインとなる。その後ネームノードが復旧した際には、ネームノードは未実行のすべてのオペレーションをリプレイする必要がある。このリプレイ処理は、クラスタの規模が大きい場合、時に30分以上を要する場合もある。[6] 一方、HDFSはセカンダリ・ネームノードと呼ばれる機能を有している。この名前は、プライマリ・ネームノードがオフラインとなった時セカンダリ・ネームノードが代替するかのように誤解を与える。しかしながら実際は、セカンダリ・ネームノードは定期的にプライマリノードに接続し、その保存されているディレクトリ情報のスナップショットをダウンロードする。セカンダリ・ネームノードはプライマリ・ネームノードの編集ログを用い、最新のディレクトリ構造を作成する。
HDFSは、通常のオペレーティングシステムにマウントできないことはまた制限のひとつである。ジョブ実行の前後にはしばしばHDFSとデータの入出力が必要になるが、マウントできないため不便である。LinuxなどいくつかのUNIXシステムでは、Filesystem in Userspaceによりこの問題を解決しているものもある。
データの複製を3回行うことは高コストである。コスト軽減のため、HDFSの最近のバージョンではErasure符号をサポートし、同じファイルの複数のブロックを結合しパリティブロックを生成している。HDFSではこのパリティブロックを非同期で生成することにより、複製生成数を3から2に減らしている。これにより、必要とされる物理ストレージ領域が3倍から約2.2倍に減少しているとの報告がある。
ジョブトラッカーとタスクトラッカー: MapReduceエンジン[編集]
ファイルシステムの上にMapReduceエンジンが動作する。MapReduceエンジンはひとつのジョブトラッカーを持ち、クライアントアプリケーションはこのジョブトラッカーに向けてMapReduceジョブを投入する。ジョブが投入されると、ジョブトラッカーはクラスタ中の利用可能なタスクトラッカーに仕事を依頼する。この時、できるだけデータに近くで仕事が行われるように努力を払う。Rack awareなファイルシステムにより、ジョブトラッカーはどのノードがデータを保持しているか、そしてどのマシンが近くにあるかを知ることができる。これによりメイン・バックボーン・ネットワークの通信トラフィックを抑える。タスクトラッカーが落ちるかタイムアウトすると、その部分のタスクは再スケジュールされる。ジョブトラッカーが落ちると、実行中の仕事は失われる。
Hadoopバージョン0.21にはチェックポイントの機能が加えられた。ジョブトラッカーはそれまでの結果をファイルシステムに記録する。ジョブトラッカーが起動した時には、そのように記録されたデータを探す。このため中断したところから仕事を再開することができる。それ以前のバージョンのHadoopでは、ジョブトラッカーが再開した時にはすべての実行中の仕事は失われる。
このアプローチには以下の欠点が知られている。
仕事のタスクトラッカーへの割り当てはとても単純である。各タスクトラッカーはある数の利用可能なスロットを持つ(例えば4スロット)。アクティブなMapまたはReduceタスク1つはスロットを1つ使用する。ジョブトラッカーはデータに最も近い利用可能なスロットを持つタスクトラッカーに仕事を割り当てる。このとき割り当てたマシンの実際の負荷を考慮しないので、実際には利用できないかもしれない。
あるタスクトラッカーがとても遅い場合、特にジョブの終りでは他のすべてが1つの遅いタスクの待ちに入り、全体のMapReduceジョブの完了が遅れてしまう。しかし、投機的実行を用いると1つのタスクを複数のスレーブ・ノードで実行することができる。

